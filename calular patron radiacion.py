{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-20-22aa8ad394c6>, line 4)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;36m  File \u001b[1;32m\"<ipython-input-20-22aa8ad394c6>\"\u001b[1;36m, line \u001b[1;32m4\u001b[0m\n\u001b[1;33m    from  patch\u001b[0m\n\u001b[1;37m               ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "from math import sin, sqrt, pi, log10, radians\n",
    "import numpy as np\n",
    "#import patch\n",
    "from  patch\n",
    "\n",
    "\n",
    "def SqrtSinPattern(Theta, Phi, *args):\n",
    "    \"\"\"\n",
    "    See Fig1 @ http://www.antenna-theory.com/basics/directivity.php\n",
    "    Expect Directivity to be 1.05dB.\n",
    "    \"\"\"\n",
    "    return sqrt(sin(radians(Theta)))\n",
    "\n",
    "\n",
    "def SinPowerPattern(Theta, Phi, *args):\n",
    "    \"\"\"\n",
    "    See Fig1 @ http://www.antenna-theory.com/basics/directivity.php\n",
    "    Expect Directivity to be 2.707dB.\n",
    "    \"\"\"\n",
    "    return sin(radians(Theta)) ** 5\n",
    "\n",
    "\n",
    "def IsotropicPattern(Theta, Phi, *args):\n",
    "    \"\"\"\n",
    "    Isotropic directional pattern. i.e. radiation is same in all directions.\n",
    "    Expect directivity to be 0dB.\n",
    "    \"\"\"\n",
    "    return 1\n",
    "\n",
    "\n",
    "def xfrange(start, stop, step):\n",
    "    \"\"\"\n",
    "    Creates range of float values.\n",
    "    \"\"\"\n",
    "    i = 0\n",
    "    while start + i * step < stop:\n",
    "        yield start + i * step\n",
    "        i += 1\n",
    "\n",
    "\n",
    "def CalcDirectivity(Efficiency, RadPatternFunction, *args):\n",
    "    \"\"\"\n",
    "    Based on calc_directivity.m from ArrayCalc.\n",
    "    Calculates peak directivity in dBi value using numerical integration.\n",
    "    If the array efficiency is set to below 100% then the returned value is referred to as Gain (dB).\n",
    "    Usage: ThetaMax, PhiMax = CalcDirectivity(RadPatternFunction, Efficiency)\n",
    "    RadPatternFunction - antennas radiation pattern function. F(Theta, Phi)\n",
    "    Efficiency - Efficiency of antenna in %. Default 100%.\n",
    "    Returned values:\n",
    "    ThetaMax - Theta value for direction of maximum directivity (Deg)\n",
    "    PhiMax - Phi value for direction of maximum directivity (Deg)\n",
    "    Integration is of the form :\n",
    "    %\n",
    "    %       360   180\n",
    "    %     Int{  Int{  (E(theta,phi)*conj(E(theta,phi))*sin(theta) d(theta) d(phi)\n",
    "    %        0     0\n",
    "    %\n",
    "    %         z\n",
    "    %         |-theta   (theta 0-180 measured from z-axis)\n",
    "    %         |/\n",
    "    %         |_____ y\n",
    "    %        /\\\n",
    "    %       /-phi       (phi 0-360 measured from x-axis)\n",
    "    %      x\n",
    "    %\n",
    "    \"\"\"\n",
    "    print(\"Calculating Directivity for \" + RadPatternFunction.__name__)\n",
    "\n",
    "    deltheta = 2                                                                # Step value of theta (Deg)\n",
    "    delphi = 2                                                                  # Step value for phi (Deg)\n",
    "\n",
    "    dth = radians(deltheta)\n",
    "    dph = radians(delphi)\n",
    "\n",
    "    Psum = 0\n",
    "    Pmax = 0\n",
    "    Thmax = 0\n",
    "    Phmax = 0\n",
    "\n",
    "    for phi in xfrange(0, 360, delphi):                                                                     # Phi Integration Loop 0-360 degrees\n",
    "        for theta in xfrange(0, 180, deltheta):                                                             # Theta Integration Loop 0-180 degrees\n",
    "            eField = RadPatternFunction(theta, phi, *args)                                       # Total E-field at point\n",
    "            Pthph = eField * np.conjugate(eField)                                                                             # Convert to power\n",
    "\n",
    "            if Pthph > Pmax:\n",
    "                Pmax = Pthph                                                                                # Store peak value\n",
    "                Thmax = theta                                                                               # Store theta value for the maximum\n",
    "                Phmax = phi                                                                                 # Store phi value for the maximum\n",
    "\n",
    "            # print(str(theta) + \",\" + str(phi) + \": \" + str(Pthph))\n",
    "            Psum = Psum + Pthph * sin(radians(theta)) * dth * dph                                           # Summation\n",
    "\n",
    "    Pmax = Pmax * (Efficiency / 100)                                                                        # Apply antenna efficiency\n",
    "\n",
    "    directivity_lin = Pmax / (Psum / (4 * pi))                                                              # Directivity (linear ratio)\n",
    "    directivity_dBi = 10 * log10(directivity_lin)                                                           # Directivity (dB wrt isotropic)\n",
    "\n",
    "    if Efficiency < 100:                                                                                    # Gain case\n",
    "        dBdiff = 10 * log10(abs(100 / Efficiency))                                                          # Difference between gain and directivity\n",
    "        print(\"Directivity = \" + str(directivity_dBi + dBdiff) + \"dBi\")                                     # Display what directivity would be for ref.\n",
    "        print(\"Efficiency = \" + str(Efficiency) + \"%\")\n",
    "        print(\"Gain = \" + str(directivity_dBi) + \"dB\")\n",
    "    else:                                                                                                   # Directivity case\n",
    "        print(\"Directivity = \" + str(directivity_dBi) + \"dBi\")\n",
    "\n",
    "    print(\"At Theta = \" + str(Thmax) + \", Phi = \" + str(Phmax))\n",
    "\n",
    "    return Thmax, Phmax\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    CalcDirectivity(100, SqrtSinPattern)\n",
    "    print(\"\\n\\n\")\n",
    "    CalcDirectivity(90, SinPowerPattern)\n",
    "    print(\"\\n\\n\")\n",
    "    CalcDirectivity(100, IsotropicPattern)\n",
    "\n",
    "    print(\"\\n\\n\")\n",
    "\n",
    "    freq = 14e9\n",
    "    Er = 3.66                                                           # RO4350B\n",
    "\n",
    "    h = 0.101e-3\n",
    "    W, L, h, Er = patch.DesignPatch(Er, h, freq)\n",
    "    CalcDirectivity(100, patch.PatchFunction, freq, W, L, h, Er)\n",
    "    fields = patch.PatchEHPlanePlot(freq, W, L, h, Er)\n",
    "    patch.SurfacePlot(fields, freq, W, L, h, Er)\n",
    "\n",
    "    W = 10.7e-3\n",
    "    L = 10.47e-3\n",
    "    h = 3e-3\n",
    "    Er = 2.5\n",
    "\n",
    "    print(\"\\n\\n\")\n",
    "    CalcDirectivity(100, patch.PatchFunction, freq, W, L, h, Er)\n",
    "    fields = patch.PatchEHPlanePlot(freq, W, L, h, Er)\n",
    "    patch.SurfacePlot(fields, freq, W, L, h, Er)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "module 'skrf' has no attribute 'Network'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-26-b49f8d76a900>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;32mimport\u001b[0m \u001b[0mskrf\u001b[0m \u001b[1;32mas\u001b[0m \u001b[0mrf\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mring_slot\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mrf\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mNetwork\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'data/ring slot.s2p'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m \u001b[1;32mfrom\u001b[0m \u001b[0mskrf\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdata\u001b[0m \u001b[1;32mimport\u001b[0m \u001b[0mring_slot\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      4\u001b[0m \u001b[0mring_slot\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mAttributeError\u001b[0m: module 'skrf' has no attribute 'Network'"
     ]
    }
   ],
   "source": [
    "import skrf as rf\n",
    "ring_slot = rf.Network('data/ring slot.s2p')\n",
    "from skrf.data import ring_slot\n",
    "ring_slot\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
